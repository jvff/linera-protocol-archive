// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions to types generated by `wit-bindgen`.
//!
//! Allows converting types used in `linera-execution` to types that can be sent to the guest Wasm
//! module.

#![allow(clippy::duplicate_mod)]

use super::{contract_system_api, service_system_api};
use crate::{CallOutcome, MessageId, SessionId, UserApplicationId};
use linera_base::{crypto::CryptoHash, data_types::Amount, identifiers::ChainId};

impl From<MessageId> for service_system_api::MessageId {
    fn from(host: MessageId) -> Self {
        service_system_api::MessageId {
            chain_id: host.chain_id.into(),
            height: host.height.0,
            index: host.index,
        }
    }
}

impl From<MessageId> for contract_system_api::MessageId {
    fn from(host: MessageId) -> Self {
        contract_system_api::MessageId {
            chain_id: host.chain_id.into(),
            height: host.height.0,
            index: host.index,
        }
    }
}

impl From<SessionId> for contract_system_api::SessionId {
    fn from(host: SessionId) -> Self {
        contract_system_api::SessionId {
            application_id: host.application_id.into(),
            index: host.index,
        }
    }
}

impl From<UserApplicationId> for service_system_api::ApplicationId {
    fn from(host: UserApplicationId) -> Self {
        service_system_api::ApplicationId {
            bytecode_id: host.bytecode_id.message_id.into(),
            creation: host.creation.into(),
        }
    }
}

impl From<UserApplicationId> for contract_system_api::ApplicationId {
    fn from(host: UserApplicationId) -> Self {
        contract_system_api::ApplicationId {
            bytecode_id: host.bytecode_id.message_id.into(),
            creation: host.creation.into(),
        }
    }
}

impl From<ChainId> for service_system_api::ChainId {
    fn from(chain_id: ChainId) -> Self {
        chain_id.0.into()
    }
}

impl From<ChainId> for contract_system_api::ChainId {
    fn from(chain_id: ChainId) -> Self {
        chain_id.0.into()
    }
}

impl From<CryptoHash> for service_system_api::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let [part1, part2, part3, part4]: [u64; 4] = crypto_hash.into();
        service_system_api::CryptoHash {
            part1,
            part2,
            part3,
            part4,
        }
    }
}

impl From<CryptoHash> for contract_system_api::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let [part1, part2, part3, part4]: [u64; 4] = crypto_hash.into();
        contract_system_api::CryptoHash {
            part1,
            part2,
            part3,
            part4,
        }
    }
}

impl From<CallOutcome> for contract_system_api::CallOutcome {
    fn from(host: CallOutcome) -> Self {
        contract_system_api::CallOutcome {
            value: host.value,
            sessions: host
                .sessions
                .into_iter()
                .map(contract_system_api::SessionId::from)
                .collect(),
        }
    }
}

impl From<Amount> for service_system_api::Amount {
    fn from(host: Amount) -> Self {
        service_system_api::Amount {
            lower_half: host.lower_half(),
            upper_half: host.upper_half(),
        }
    }
}

impl From<Amount> for contract_system_api::Amount {
    fn from(host: Amount) -> Self {
        contract_system_api::Amount {
            lower_half: host.lower_half(),
            upper_half: host.upper_half(),
        }
    }
}
