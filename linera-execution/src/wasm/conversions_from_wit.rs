// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions from types generated by `wit-bindgen`.
//!
//! Allows converting types returned from a Wasm module into types that can be used with the rest
//! of the crate.

#![allow(clippy::duplicate_mod)]

use super::{contract_system_api, service_system_api};
use crate::{SessionId, UserApplicationId};
use linera_base::{
    crypto::CryptoHash,
    data_types::BlockHeight,
    identifiers::{BytecodeId, ChainId, MessageId},
};

impl From<contract_system_api::SessionId> for SessionId {
    fn from(guest: contract_system_api::SessionId) -> Self {
        SessionId {
            application_id: guest.application_id.into(),
            index: guest.index,
        }
    }
}

impl From<contract_system_api::ApplicationId> for UserApplicationId {
    fn from(guest: contract_system_api::ApplicationId) -> Self {
        UserApplicationId {
            bytecode_id: guest.bytecode_id.into(),
            creation: guest.creation.into(),
        }
    }
}

impl From<contract_system_api::MessageId> for BytecodeId {
    fn from(guest: contract_system_api::MessageId) -> Self {
        BytecodeId::new(guest.into())
    }
}

impl From<contract_system_api::MessageId> for MessageId {
    fn from(guest: contract_system_api::MessageId) -> Self {
        MessageId {
            chain_id: guest.chain_id.into(),
            height: BlockHeight(guest.height),
            index: guest.index,
        }
    }
}

impl From<contract_system_api::CryptoHash> for ChainId {
    fn from(guest: contract_system_api::CryptoHash) -> Self {
        ChainId(guest.into())
    }
}

impl From<contract_system_api::CryptoHash> for CryptoHash {
    fn from(guest: contract_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        CryptoHash::from(integers)
    }
}

impl From<service_system_api::ApplicationId> for UserApplicationId {
    fn from(guest: service_system_api::ApplicationId) -> Self {
        UserApplicationId {
            bytecode_id: guest.bytecode_id.into(),
            creation: guest.creation.into(),
        }
    }
}

impl From<service_system_api::MessageId> for BytecodeId {
    fn from(guest: service_system_api::MessageId) -> Self {
        BytecodeId::new(guest.into())
    }
}

impl From<service_system_api::MessageId> for MessageId {
    fn from(guest: service_system_api::MessageId) -> Self {
        MessageId {
            chain_id: guest.chain_id.into(),
            height: BlockHeight(guest.height),
            index: guest.index,
        }
    }
}

impl From<service_system_api::CryptoHash> for ChainId {
    fn from(guest: service_system_api::CryptoHash) -> Self {
        ChainId(guest.into())
    }
}

impl From<service_system_api::CryptoHash> for CryptoHash {
    fn from(guest: service_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        CryptoHash::from(integers)
    }
}
