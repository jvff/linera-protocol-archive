// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions from types declared in [`linera-sdk`] to types generated by [`wit-bindgen`].

<<<<<<< HEAD
use linera_base::{
    crypto::CryptoHash,
    data_types::{Amount, Resources},
    identifiers::{Account, ApplicationId, ChainId, ChannelName, Destination, MessageId, Owner},
};

use super::wit_system_api;
<<<<<<< HEAD
use crate::SendMessageRequest;
=======
use crate::OutgoingMessage;
=======
use super::wit::{contract_entrypoints as wit_entrypoints, contract_system_api as wit_system_api};
use crate::{
    ApplicationCallOutcome, ExecutionOutcome, MessageKind, OutgoingMessage, RawSessionCallOutcome,
};
use linera_base::{
    crypto::CryptoHash,
    data_types::{BlockHeight, Resources},
    identifiers::{
        Account, ApplicationId, BytecodeId, ChainId, ChannelName, Destination, MessageId, Owner,
        SessionId,
    },
};

impl From<CryptoHash> for wit_entrypoints::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let parts = <[u64; 4]>::from(crypto_hash);

        wit_entrypoints::CryptoHash {
            part1: parts[0],
            part2: parts[1],
            part3: parts[2],
            part4: parts[3],
        }
    }
}

impl From<ChainId> for wit_entrypoints::ChainId {
    fn from(chain_id: ChainId) -> Self {
        wit_entrypoints::ChainId {
            inner0: chain_id.0.into(),
        }
    }
}

impl From<ApplicationCallOutcome<Vec<u8>, Vec<u8>, Vec<u8>>>
    for wit_entrypoints::ApplicationCallOutcome
{
    fn from(outcome: ApplicationCallOutcome<Vec<u8>, Vec<u8>, Vec<u8>>) -> Self {
        wit_entrypoints::ApplicationCallOutcome {
            value: outcome.value,
            execution_outcome: outcome.execution_outcome.into(),
            create_sessions: outcome.create_sessions,
        }
    }
}

impl From<RawSessionCallOutcome> for wit_entrypoints::SessionCallOutcome {
    fn from(outcome: RawSessionCallOutcome) -> Self {
        wit_entrypoints::SessionCallOutcome {
            inner: outcome.inner.into(),
            close_session: outcome.close_session,
        }
    }
}

impl From<OutgoingMessage<Vec<u8>>> for wit_entrypoints::RawOutgoingMessage {
    fn from(message: OutgoingMessage<Vec<u8>>) -> Self {
        Self {
            destination: message.destination.into(),
            authenticated: message.authenticated,
            kind: message.kind.into(),
            grant: message.grant.into(),
            message: message.message,
        }
    }
}

impl From<MessageKind> for wit_entrypoints::MessageKind {
    fn from(kind: MessageKind) -> Self {
        match kind {
            MessageKind::Simple => wit_entrypoints::MessageKind::Simple,
            MessageKind::Protected => wit_entrypoints::MessageKind::Protected,
            MessageKind::Tracked => wit_entrypoints::MessageKind::Tracked,
            MessageKind::Bouncing => wit_entrypoints::MessageKind::Bouncing,
        }
    }
}

impl From<Resources> for wit_entrypoints::Resources {
    fn from(resources: Resources) -> Self {
        wit_entrypoints::Resources {
            fuel: resources.fuel,
            read_operations: resources.read_operations,
            write_operations: resources.write_operations,
            bytes_to_read: resources.bytes_to_read,
            bytes_to_write: resources.bytes_to_write,
            messages: resources.messages,
            message_size: resources.message_size,
            storage_size_delta: resources.storage_size_delta,
        }
    }
}

impl From<ExecutionOutcome<Vec<u8>>> for wit_entrypoints::RawExecutionOutcome {
    fn from(outcome: ExecutionOutcome<Vec<u8>>) -> Self {
        let messages = outcome
            .messages
            .into_iter()
            .map(wit_entrypoints::RawOutgoingMessage::from)
            .collect();

        let subscribe = outcome
            .subscribe
            .into_iter()
            .map(|(subscription, chain_id)| (subscription.into(), chain_id.into()))
            .collect();

        let unsubscribe = outcome
            .unsubscribe
            .into_iter()
            .map(|(subscription, chain_id)| (subscription.into(), chain_id.into()))
            .collect();

        wit_entrypoints::RawExecutionOutcome {
            authenticated_signer: None,
            refund_grant_to: outcome.refund_grant_to.map(Account::into),
            messages,
            subscribe,
            unsubscribe,
        }
    }
}

impl From<Account> for wit_entrypoints::Account {
    fn from(account: Account) -> Self {
        wit_entrypoints::Account {
            chain_id: account.chain_id.into(),
            owner: account.owner.map(Owner::into),
        }
    }
}

impl From<Owner> for wit_entrypoints::Owner {
    fn from(owner: Owner) -> Self {
        wit_entrypoints::Owner {
            inner0: owner.0.into(),
        }
    }
}

impl From<Destination> for wit_entrypoints::Destination {
    fn from(destination: Destination) -> Self {
        match destination {
            Destination::Recipient(chain_id) => {
                wit_entrypoints::Destination::Recipient(chain_id.into())
            }
            Destination::Subscribers(subscription) => {
                wit_entrypoints::Destination::Subscribers(subscription.into())
            }
        }
    }
}

impl From<ChannelName> for wit_entrypoints::ChannelName {
    fn from(name: ChannelName) -> Self {
        wit_entrypoints::ChannelName {
            inner0: name.into_bytes(),
        }
    }
}
>>>>>>> 3e89af2a50 (WIP)
>>>>>>> b5b1fc5059 (WIP)

impl From<CryptoHash> for wit_system_api::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let parts = <[u64; 4]>::from(crypto_hash);

        wit_system_api::CryptoHash {
            part1: parts[0],
            part2: parts[1],
            part3: parts[2],
            part4: parts[3],
        }
    }
}

<<<<<<< HEAD
impl From<ChainId> for wit_system_api::CryptoHash {
    fn from(chain_id: ChainId) -> Self {
        chain_id.0.into()
    }
}

impl From<Owner> for wit_system_api::CryptoHash {
    fn from(owner: Owner) -> Self {
        wit_system_api::CryptoHash::from(owner.0)
    }
}

impl From<Amount> for wit_system_api::Amount {
    fn from(host: Amount) -> Self {
        wit_system_api::Amount {
            lower_half: host.lower_half(),
            upper_half: host.upper_half(),
        }
    }
}

impl From<Account> for wit_system_api::Account {
    fn from(account: Account) -> Self {
        wit_system_api::Account {
            chain_id: account.chain_id.0.into(),
            owner: account.owner.map(|owner| owner.into()),
=======
impl From<BlockHeight> for wit_system_api::BlockHeight {
    fn from(block_height: BlockHeight) -> Self {
        wit_system_api::BlockHeight {
            inner0: block_height.0,
>>>>>>> 3e89af2a50 (WIP)
        }
    }
}

impl From<ChainId> for wit_system_api::ChainId {
    fn from(chain_id: ChainId) -> Self {
        wit_system_api::ChainId {
            inner0: chain_id.0.into(),
        }
    }
}

impl From<ApplicationId> for wit_system_api::ApplicationId {
    fn from(application_id: ApplicationId) -> Self {
        wit_system_api::ApplicationId {
            bytecode_id: application_id.bytecode_id.into(),
            creation: application_id.creation.into(),
        }
    }
}

<<<<<<< HEAD
impl From<MessageId> for wit_system_api::MessageId {
    fn from(message_id: MessageId) -> Self {
        wit_system_api::MessageId {
            chain_id: wit_system_api::ChainId {
                inner0: message_id.chain_id.0.into(),
            },
            height: wit_system_api::BlockHeight {
                inner0: message_id.height.0,
            },
=======
impl From<BytecodeId> for wit_system_api::BytecodeId {
    fn from(bytecode_id: BytecodeId) -> Self {
        wit_system_api::BytecodeId {
            message_id: bytecode_id.message_id.into(),
        }
    }
}

impl From<MessageId> for wit_system_api::MessageId {
    fn from(message_id: MessageId) -> Self {
        wit_system_api::MessageId {
            chain_id: message_id.chain_id.into(),
            height: message_id.height.into(),
>>>>>>> 3e89af2a50 (WIP)
            index: message_id.index,
        }
    }
}

<<<<<<< HEAD
impl<'a> From<&'a SendMessageRequest<Vec<u8>>> for wit_system_api::SendMessageRequest<'a> {
    fn from(message: &'a SendMessageRequest<Vec<u8>>) -> Self {
=======
<<<<<<< HEAD
impl<'a> From<&'a OutgoingMessage<Vec<u8>>> for wit_system_api::OutgoingMessage<'a> {
    fn from(message: &'a OutgoingMessage<Vec<u8>>) -> Self {
>>>>>>> b5b1fc5059 (WIP)
        Self {
            destination: (&message.destination).into(),
            authenticated: message.authenticated,
            is_tracked: message.is_tracked,
            resources: message.grant.into(),
            message: &message.message,
        }
    }
}

impl<'a> From<&'a Destination> for wit_system_api::Destination<'a> {
    fn from(destination: &'a Destination) -> Self {
        match destination {
            Destination::Recipient(chain_id) => {
                wit_system_api::Destination::Recipient(chain_id.0.into())
            }
            Destination::Subscribers(subscription) => {
                wit_system_api::Destination::Subscribers(subscription.into())
            }
        }
    }
}

impl<'a> From<&'a ChannelName> for wit_system_api::ChannelName<'a> {
    fn from(name: &'a ChannelName) -> Self {
        wit_system_api::ChannelName {
            name: name.as_ref(),
        }
    }
}

impl From<Resources> for wit_system_api::Resources {
    fn from(resources: Resources) -> Self {
        wit_system_api::Resources {
            fuel: resources.fuel,
            read_operations: resources.read_operations,
            write_operations: resources.write_operations,
            bytes_to_read: resources.bytes_to_read,
            bytes_to_write: resources.bytes_to_write,
            messages: resources.messages,
            message_size: resources.message_size,
            storage_size_delta: resources.storage_size_delta,
=======
impl From<SessionId> for wit_system_api::SessionId {
    fn from(session_id: SessionId) -> Self {
        wit_system_api::SessionId {
            application_id: session_id.application_id.into(),
            index: session_id.index,
>>>>>>> 3e89af2a50 (WIP)
        }
    }
}

impl From<log::Level> for wit_system_api::LogLevel {
    fn from(level: log::Level) -> Self {
        match level {
            log::Level::Trace => wit_system_api::LogLevel::Trace,
            log::Level::Debug => wit_system_api::LogLevel::Debug,
            log::Level::Info => wit_system_api::LogLevel::Info,
            log::Level::Warn => wit_system_api::LogLevel::Warn,
            log::Level::Error => wit_system_api::LogLevel::Error,
        }
    }
}
